Question - Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.

Example 1:

Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
Example 2:

Input: nums = [1,2,3], k = 0
Output: 0

LeetCode - https://leetcode.com/problems/subarray-product-less-than-k/description/
GFG - https://www.geeksforgeeks.org/number-subarrays-product-less-k/

Solution - Let's first start with the first element and check the product so if product is less than K then update the count now for second check the product if less than k then we need to find out how many total
           no's can be made by including that no so it can be calculated using -> (endIndex - startIndex) + 1 here endIndex is the index of the current no to be added and the start index is the index from where
           we are seeing the current sub-array and how this formula is working is suppose we already have one subarray [10, 2] and the current count is 3 and now we are adding another element 5 so total no. that
           can be generated by adding 5 is 1 length no (5) + two length no (2, 5) + three length no (10, 2, 5) so it's 3 and from formula (2 - 0) + 1 = 3.

class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int product = 1, count = 0, start = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] < k){
                if(nums[i] * product < k){
                    count = count + 1 + (i-start);
                    product = nums[i] * product;
                } else {
                    // slide the window from left
                    while(start < i && product * nums[i] >= k){
                        product = product / nums[start];
                        start++;
                    }
                    count = count + 1 + (i-start);
                    product = product * nums[i];
                }
            } else{
                product = 1;
                start = i+1;
            }
        }
        return count;
    }
}

GFG solution -

static int
    countSubArrayProductLessThanK(ArrayList<Integer> a,
                                  long k)
    {
        int n = a.size();
        long p = 1;
        int res = 0;
        for (int start = 0, end = 0; end < n; end++) {

            // Move right bound by 1 step.
            // Update the product.
            p *= a.get(end);

            // Move left bound so guarantee that
            // p is again less than k.
            while (start < end && p >= k)
                p /= a.get(start++);

            // If p is less than k, update the counter.
            // Note that this is working even for
            // (start == end): it means that the
            // previous window cannot grow anymore
            // and a single array element is the only
            // addendum.
            if (p < k) {
                int len = end - start + 1;
                res += len;
            }
        }

        return res;
    }
